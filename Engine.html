<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="Engine.html">Engine</a></li></li><li><li><a href="Log.html">Log</a></li></li><li><li><a href="types/Eval.html">types/Eval</a></li></li><li><li><a href="types/Graph.html">types/Graph</a></li></li><li><li><a href="types/Log.html">types/Log</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#type.Engine">Engine</a></li></li></ul></nav><div class="documentation"><h1>Engine</h1><p>Adapton in Motoko, as a class-based generic &quot;functor&quot;.</p>
<p>This module defines a general-purpose cache and dependence graph
system.  See <code>EvalType</code> module for details about its parameters.</p>
<p>In brief, the client of this API chooses 4 representations
for a customized incremental interpter that they define:</p>
<ul><li><code>Name</code> -- the identity of cached information; must be unique.</li><li><code>Val</code> -- the type of data stored in Named Refs, and produced by successfully-evaluated Closures.</li><li><code>Error</code> -- the type of data produced when evaluation errors occur. Misusing the cache can also produce Errors.</li><li><code>Closure</code> -- the representation of suspended computations stored in Named Thunks.</li></ul>

<h2 id="Cache-operations">Cache operations</h2>

<p>Using the types chosen above, the Engine exposes three important cache operations:</p>
<ul><li><code>put</code> a Value into a Ref, located at a Name.</li></ul>

<ul><li><code>putThunk</code> a suspended Closure into a Thunk, located at a Name.</li></ul>

<ul><li><code>get</code> the Value of a Ref, or the result of evaluating a Thunk, by its Name.</li></ul>

<h2 id="Incremental-caching-and-re-computation-is-automatic">Incremental caching and re-computation is automatic</h2>

<p>Behind the scenes, Adapton caches the results and dependencies of
user-defined thunks as they evaluate.</p>
<p>Sometimes, a single thunk is demanded repeatedly amidst a series of
changes (via <code>put</code> or <code>putThunk</code>).  When a previously-evaluated thunk
is not &quot;stale&quot;, Adapton reuses its past cached results and avoids
recomputing it.  However, when these cached results are stale, Adapton
will automatically recompute them and update its cache information, in
place.  An overview of more details are below, and they consist of
&quot;dirtying&quot; and &quot;cleaning&quot; operations over the graph that preserve its
invariants.  See adapton.org for papers and the underlying theory.</p>
<h2 id="Details-Cleaning-and-dirtying-algorithms">Details: Cleaning and dirtying algorithms</h2>

<p>The algorithms in this module are only used by Adapton, not
externally.  They permit the main API (put, putThunk, get) to dirty
and clean edges while enforcing certain invariants, given below.</p>
<h3 id="Graph-definitions">Graph definitions:</h3>

<ul><li><p>Each node is either a ref node or a thunk node.</p>
</li><li><p>Each edge is directed and arises from a thunk node;
 its target can either be a thunk node or a ref node.</p>
</li><li><p>An edge is either dirty or clean.</p>
</li><li><p>A thunk node is dirty if and only if it has at least one outgoing dirty edge.</p>
</li><li><p>Ref nodes are never themselves dirty, but their dependent (incoming)
 edges can <em>each</em> be dirty or clean.  When at least one such edge is
 dirty for a ref node, we have encoded a situation where the ref node
 changes to a &quot;new&quot; value, distinct from at least <em>some</em> past recorded
 action on this dirty edge.</p>
</li></ul>

<h3 id="Clean-dirty-invariant">Clean/dirty invariant</h3>

<p>The clean/dirty invariant for each edge is a global one, over the
status of the entire graph:</p>
<ul><li>If an edge <code>E</code> is dirty, then all its dependent
 (&quot;up-demand-dep&quot;/incoming) edges are also dirty:</li></ul>

<p> <code>for all E2 in upFrom(E), isDirty(E2)</code></p>
<ul><li>If an edge <code>E</code> is clean, then all of its dependencies
 (&quot;down-demand-dep&quot;/outgoing) edges are also clean:</li></ul>

<p> <code>for all E2 in downFrom(E), not(isDirty(E2))</code></p>
<p>The sets of edges <code>upFrom(E)</code> and <code>downFrom(E)</code> used above denote the
transitive closure of edges that forms by following the dependent
direction of each edge, or dependency direction of each edge,
respectively.</p>
<h3 id="Further-discussion">Further discussion</h3>

<ul><li><p>All node identities used here are determined by explicit, user-provided names.</p>
</li><li><p>Nominal Adapton (here) supports &quot;classic Adapton&quot; by choosing names
 structurally, as &quot;full hashes&quot;; we do not yet directly support that
 usage here, but it could be easily added later as another feature.</p>
</li><li><p>This code is based on these two Adapton papers:</p>
<ol><li><p><a href="https://arxiv.org/abs/1503.07792">Incremental Computation with Names</a></p>
</li><li><p><a href="https://dl.acm.org/doi/abs/10.1145/2666356.2594324">Adapton: composable, demand-driven incremental computation</a></p>
</li></ol></li></ul><div class="declaration"><h4 class="class-declaration" id="type.Engine"><span class="keyword">class </span><span class="classname">Engine</span>&lt;<span class="type">Name</span>, <span class="type">Val</span>, <span class="type">Error</span>, <span class="type">Closure</span>&gt;(<span class="parameter">evalOps</span> : <a href="types/Eval.html#type.EvalOps"><span class="type">E.EvalOps</span></a>&lt;<span class="type">Name</span>, <span class="type">Val</span>, <span class="type">Error</span>, <span class="type">Closure</span>&gt;, <span class="parameter">_logFlag</span> : <span class="type">Bool</span>)</h4><div class="declaration"><h4 class="function" id="Engine.setEvalClosure"><code><span class="keyword">public func </span><span class="fnname">setEvalClosure</span>(<span class="parameter">evalClosure</span> : <a href="types/Eval.html#type.EvalClosure"><span class="type">E.EvalClosure</span></a>&lt;<span class="type">Val</span>, <span class="type">Error</span>, <span class="type">Closure</span>&gt;)</code></h4><p></p></div><div class="declaration"><h4 class="function" id="Engine.put"><code><span class="keyword">public func </span><span class="fnname">put</span>(<span class="parameter">n</span> : <span class="type">Name</span>, <span class="parameter">val</span> : <span class="type">Val</span>) : <span class="type">R.Result</span>&lt;<span class="type">Name</span>, <a href="types/Graph.html#type.PutError"><span class="type">G.PutError</span></a>&gt;</code></h4><p></p></div><div class="declaration"><h4 class="function" id="Engine.putThunk"><code><span class="keyword">public func </span><span class="fnname">putThunk</span>(<span class="parameter">n</span> : <span class="type">Name</span>, <span class="parameter">clos</span> : <span class="type">Closure</span>) : <span class="type">R.Result</span>&lt;<span class="type">Name</span>, <a href="types/Graph.html#type.PutError"><span class="type">G.PutError</span></a>&gt;</code></h4><p></p></div><div class="declaration"><h4 class="function" id="Engine.get"><code><span class="keyword">public func </span><span class="fnname">get</span>(<span class="parameter">n</span> : <span class="type">Name</span>) : <span class="type">R.Result</span>&lt;{#ok : <span class="type">Val</span>; #err : <span class="type">Error</span>}, <a href="types/Graph.html#type.GetError"><span class="type">G.GetError</span></a>&gt;</code></h4><p></p></div><p></p></div></div></body></html>